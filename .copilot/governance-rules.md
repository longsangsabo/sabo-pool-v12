# üéØ SABO Arena - Complete AI Assistant Governance System

> **COMPREHENSIVE RULES** for all AI assistants working on SABO Arena project

## üö® CRITICAL MANDATORY RULES

### **RULE #0: READ FIRST, ACT SECOND**
```
üî¥ NEVER make changes without reading these rules
üî¥ NEVER assume anything about project structure
üî¥ NEVER create files without checking existing patterns
‚úÖ ALWAYS read documentation first
‚úÖ ALWAYS follow established patterns
‚úÖ ALWAYS ask before major changes
```

---

## üìã 1. FILE & DIRECTORY MANAGEMENT

### **1.1 File Naming Rules**
- **Format**: kebab-case (lowercase + hyphens)
- **Length**: Maximum 30 characters (excluding extension)
- **Pattern**: `[category]-[function]-[type].[ext]`
- **Forbidden**: UPPER_CASE, camelCase, snake_case, spaces

### **1.2 Directory Structure Rules**
```
‚úÖ ALLOWED locations for new files:
‚îú‚îÄ‚îÄ apps/sabo-admin/src/          # Admin app code
‚îú‚îÄ‚îÄ apps/sabo-user/src/           # User app code  
‚îú‚îÄ‚îÄ packages/shared-*/src/        # Shared package code
‚îú‚îÄ‚îÄ docs/[01-11]-*/               # Documentation sections
‚îú‚îÄ‚îÄ database_migration/           # DB migration files
‚îú‚îÄ‚îÄ scripts/                      # Utility scripts
‚îú‚îÄ‚îÄ e2e/                         # End-to-end tests

‚ùå FORBIDDEN locations:
‚îú‚îÄ‚îÄ / (root directory)            # Only README.md, SYSTEM_OVERVIEW.md allowed
‚îú‚îÄ‚îÄ arbitrary new directories     # Must follow established structure
```

### **1.3 File Creation Rules**
- **Check first**: Search for existing similar files
- **Follow patterns**: Use existing file structures as templates
- **Documentation**: Create README.md for new directories
- **No duplicates**: Don't create functionality that already exists

---

## üèóÔ∏è 2. CODE ARCHITECTURE RULES

### **2.1 Component Organization**
```typescript
// ‚úÖ CORRECT: Use shared packages
import { Button } from '@/packages/shared-ui'
import { useAuth } from '@/packages/shared-auth'
import { Tournament } from '@/packages/shared-types'

// ‚ùå WRONG: Create duplicate components
// Don't create new Button in apps/ if shared one exists
```

### **2.2 Business Logic Rules**
- **Shared logic**: Must go in `packages/shared-business/`
- **App-specific**: Only UI and routing logic in apps/
- **Types**: All TypeScript types in `packages/shared-types/`
- **Utils**: Common utilities in `packages/shared-utils/`

### **2.3 Database Rules**
- **Migrations**: Only in `database_migration/migrations/`
- **Schema changes**: Must include rollback scripts
- **Supabase**: Use existing connection patterns
- **No direct SQL**: Use Supabase client methods

---

## üé® 3. UI/UX STANDARDS

### **3.1 Design System Compliance**
```typescript
// ‚úÖ CORRECT: Use design tokens
import { colors, spacing, typography } from '@/packages/design-tokens'

const StyledButton = styled.button`
  background: ${colors.primary.main};
  padding: ${spacing.md};
  font-size: ${typography.body.fontSize};
`

// ‚ùå WRONG: Inline styles or arbitrary values
const BadButton = styled.button`
  background: #3498db;  // Use design tokens instead
  padding: 16px;        // Use spacing tokens instead
`
```

### **3.2 Component Standards**
- **Reuse first**: Check `packages/shared-ui/` before creating
- **Variants**: Use existing component variants
- **Props**: Follow established prop patterns
- **Styling**: Use Tailwind classes or styled-components with tokens

### **3.3 Responsive Design**
- **Mobile-first**: All components must work on mobile
- **Breakpoints**: Use established breakpoint system
- **Touch-friendly**: Minimum 44px touch targets

---

## üîß 4. DEVELOPMENT WORKFLOW

### **4.1 Before Starting Any Task**
```bash
# 1. Read project documentation
cat README.md
cat SYSTEM_OVERVIEW.md  
cat NAMING_CONVENTION_PLAN.md

# 2. Check existing implementations
find . -name "*keyword*" -type f

# 3. Understand the request
# - What exactly is needed?
# - Where should it be implemented?
# - What existing patterns can be used?
```

### **4.2 Code Quality Rules**
- **TypeScript**: All new code must be TypeScript
- **ESLint**: Follow existing ESLint configuration
- **Prettier**: Use project Prettier settings
- **Comments**: Document complex business logic
- **Tests**: Add tests for new functionality

### **4.3 Git Workflow**
- **Commits**: Use conventional commit messages
- **Branches**: Follow established branching strategy
- **PRs**: Include clear description and testing notes

---

## üìö 5. DOCUMENTATION REQUIREMENTS

### **5.1 When to Update Documentation**
- ‚úÖ New features added
- ‚úÖ API changes made
- ‚úÖ Architecture modifications
- ‚úÖ New dependencies added
- ‚úÖ Configuration changes

### **5.2 Documentation Standards**
```markdown
# ‚úÖ GOOD documentation structure:
## Overview
Brief description of what this does

## Usage
Code examples and implementation guide

## API Reference
Parameters, return values, types

## Examples
Real-world usage examples

# ‚ùå BAD documentation:
- No examples
- Missing context
- Outdated information
```

### **5.3 Location Rules**
- **Feature docs**: `docs/08-features/`
- **API docs**: `docs/06-api/`
- **Development guides**: `docs/04-development/`
- **Component docs**: In component source files
- **Package docs**: README.md in package root

---

## üö´ 6. FORBIDDEN ACTIONS

### **6.1 File Operations**
- ‚ùå Creating files in project root (except approved ones)
- ‚ùå Renaming files without checking all references
- ‚ùå Moving files between apps/packages without approval
- ‚ùå Deleting files without understanding dependencies
- ‚ùå Creating temporary files without cleanup

### **6.2 Code Operations**
- ‚ùå Adding new dependencies without approval
- ‚ùå Modifying package.json scripts without consultation
- ‚ùå Changing build configuration without testing
- ‚ùå Copying code instead of creating shared packages
- ‚ùå Hardcoding values that should be configurable

### **6.3 Architecture Operations**
- ‚ùå Creating new database tables without migration scripts
- ‚ùå Changing API endpoints without updating documentation
- ‚ùå Modifying authentication flow without security review
- ‚ùå Adding external services without approval

---

## ‚úÖ 7. REQUIRED WORKFLOWS

### **7.1 Creating New Features**
1. **Research**: Check if similar feature exists
2. **Plan**: Identify affected components/packages
3. **Design**: Follow existing patterns and design system
4. **Implement**: Use shared packages, follow conventions
5. **Test**: Add appropriate tests
6. **Document**: Update relevant documentation
7. **Review**: Check compliance with all rules

### **7.2 Modifying Existing Features**
1. **Understand**: Read existing code and documentation
2. **Impact analysis**: Identify all affected areas
3. **Backward compatibility**: Ensure no breaking changes
4. **Testing**: Test all affected functionality
5. **Documentation**: Update changed behavior

### **7.3 Adding Dependencies**
1. **Justify**: Explain why existing solutions don't work
2. **Research**: Check for similar existing dependencies
3. **Security**: Verify package security and maintenance
4. **Impact**: Understand bundle size and performance impact
5. **Approval**: Get approval before adding

---

## üéØ 8. QUALITY STANDARDS

### **8.1 Code Quality Metrics**
- **TypeScript coverage**: 100% for new code
- **ESLint compliance**: Zero violations
- **Test coverage**: Minimum 80% for business logic
- **Performance**: No unnecessary re-renders or API calls
- **Accessibility**: WCAG 2.1 AA compliance

### **8.2 Documentation Quality**
- **Completeness**: All features documented
- **Accuracy**: Documentation matches implementation
- **Examples**: Working code examples provided
- **Navigation**: Clear cross-references and links
- **Maintenance**: Updated with every change

### **8.3 User Experience Standards**
- **Loading states**: All async operations show loading
- **Error handling**: Graceful error messages
- **Responsiveness**: Works on all device sizes
- **Performance**: Fast loading and interaction
- **Accessibility**: Keyboard navigation and screen readers

---

## üîç 9. VALIDATION & COMPLIANCE

### **9.1 Pre-commit Checklist**
- [ ] Code follows TypeScript standards
- [ ] ESLint and Prettier passed
- [ ] Tests added/updated and passing
- [ ] Documentation updated
- [ ] No console.log or debug code
- [ ] No hardcoded values
- [ ] File naming conventions followed
- [ ] No unauthorized file locations

### **9.2 Automated Checks**
```bash
# Run compliance validation
./.copilot/validate-compliance.sh

# Check code quality
npm run lint
npm run type-check
npm run test

# Verify build
npm run build
```

### **9.3 Manual Review Points**
- Does this follow existing patterns?
- Is this the right place for this code?
- Will this scale well?
- Is error handling adequate?
- Are edge cases covered?

---

## üÜò 10. EMERGENCY PROCEDURES

### **10.1 If You Made a Mistake**
1. **STOP**: Don't make more changes
2. **Document**: List exactly what was changed
3. **Revert**: Offer to undo the changes
4. **Learn**: Understand what should have been done
5. **Proceed**: Follow correct procedure

### **10.2 If You're Unsure**
1. **ASK**: Request clarification from user
2. **RESEARCH**: Check documentation and existing code
3. **PLAN**: Explain your intended approach
4. **VERIFY**: Confirm before executing

### **10.3 If Rules Conflict**
1. **Prioritize**: User safety and data integrity first
2. **Consult**: Ask user for guidance
3. **Document**: Note the conflict for future resolution
4. **Choose**: Most conservative approach

---

## üìû 11. SUPPORT & ESCALATION

### **11.1 Documentation References**
- **Project Overview**: `SYSTEM_OVERVIEW.md`
- **File Naming**: `NAMING_CONVENTION_PLAN.md`
- **Documentation Structure**: `docs/README.md`
- **Development Guide**: `docs/04-development/development-guide.md`
- **Architecture Guide**: `docs/03-architecture/system-overview.md`

### **11.2 Quick Help Commands**
```bash
# Get project overview
cat SYSTEM_OVERVIEW.md

# Check naming rules
cat NAMING_CONVENTION_PLAN.md

# Find existing implementations
grep -r "keyword" --include="*.ts" --include="*.tsx"

# Check documentation structure
tree docs/ -L 2
```

### **11.3 Escalation Path**
1. **Level 1**: Check documentation
2. **Level 2**: Search existing codebase
3. **Level 3**: Ask user for clarification
4. **Level 4**: Propose solution with explanation

---

## üèÜ 12. SUCCESS METRICS

### **12.1 A Good AI Assistant Session Has:**
- ‚úÖ Zero unauthorized file creation
- ‚úÖ 100% naming convention compliance
- ‚úÖ No duplicate functionality
- ‚úÖ Updated documentation
- ‚úÖ Followed existing patterns
- ‚úÖ Asked for approval on major changes
- ‚úÖ Added appropriate tests
- ‚úÖ Maintained code quality standards

### **12.2 Project Health Indicators**
- ‚úÖ Consistent file organization
- ‚úÖ No code duplication
- ‚úÖ Complete documentation
- ‚úÖ Working tests
- ‚úÖ Fast development velocity
- ‚úÖ Easy onboarding for new developers

---

**Remember**: These rules exist to maintain high code quality, prevent technical debt, and ensure all AI assistants work systematically to build a maintainable, scalable system! üéØ‚ú®

**Last Updated**: August 31, 2025
**Version**: 1.0
**Status**: Active & Enforced
