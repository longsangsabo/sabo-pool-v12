# Copilot Instructions: Modern Flutter Development Standards

## üéØ CODING PHILOSOPHY
Write Flutter code using the LATEST modern patterns, best practices, and industry standards as of 2024-2025. Prioritize clean architecture, performance, maintainability, and developer experience.

## üì± MODERN FLUTTER PATTERNS TO USE

### 1. STATE MANAGEMENT
**ALWAYS use Riverpod 2.4+ (NOT Provider or setState)**
```dart
// ‚úÖ MODERN - Riverpod with code generation
@riverpod
class AuthNotifier extends _$AuthNotifier {
  @override
  Future<User?> build() async {
    return await authRepository.getCurrentUser();
  }
  
  Future<void> signIn(String email, String password) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() => 
      authRepository.signIn(email, password)
    );
  }
}

// ‚ùå OLD - setState or Provider
class _AuthState extends State<AuthWidget> {
  bool loading = false;
  void setState(() => loading = true);
}
```

### 2. ARCHITECTURE PATTERNS
**ALWAYS use Feature-First Clean Architecture**
```dart
// ‚úÖ MODERN - Feature-first structure
lib/
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îÇ       ‚îú‚îÄ‚îÄ data/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ repositories/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ datasources/
‚îÇ       ‚îú‚îÄ‚îÄ domain/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ usecases/
‚îÇ       ‚îî‚îÄ‚îÄ presentation/
‚îÇ           ‚îú‚îÄ‚îÄ providers/
‚îÇ           ‚îú‚îÄ‚îÄ screens/
‚îÇ           ‚îî‚îÄ‚îÄ widgets/

// ‚ùå OLD - Layer-first structure
lib/
‚îú‚îÄ‚îÄ screens/
‚îú‚îÄ‚îÄ widgets/
‚îî‚îÄ‚îÄ services/
```

### 3. WIDGET COMPOSITION
**ALWAYS use modern widget patterns with hooks and extensions**
```dart
// ‚úÖ MODERN - Hooks + Extensions + ConsumerWidget
class LoginScreen extends ConsumerHookWidget {
  const LoginScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final emailController = useTextEditingController();
    final authState = ref.watch(authNotifierProvider);
    
    return Scaffold(
      body: authState.when(
        data: (user) => user != null 
          ? const HomeScreen()
          : LoginForm(controller: emailController),
        loading: () => const LoadingWidget(),
        error: (error, _) => ErrorWidget(error.toString()),
      ),
    );
  }
}

// ‚ùå OLD - StatefulWidget with setState
class LoginScreen extends StatefulWidget {
  @override
  _LoginScreenState createState() => _LoginScreenState();
}
```

### 4. ERROR HANDLING
**ALWAYS use AsyncValue and Result patterns**
```dart
// ‚úÖ MODERN - AsyncValue with proper error handling
@riverpod
Future<List<Tournament>> tournaments(TournamentsRef ref) async {
  return ref.watch(tournamentRepositoryProvider).getTournaments();
}

Widget build(BuildContext context, WidgetRef ref) {
  final tournamentsAsync = ref.watch(tournamentsProvider);
  
  return tournamentsAsync.when(
    data: (tournaments) => TournamentList(tournaments: tournaments),
    loading: () => const TournamentListShimmer(),
    error: (error, stackTrace) => ErrorView(
      error: error,
      onRetry: () => ref.invalidate(tournamentsProvider),
    ),
  );
}

// ‚ùå OLD - Try-catch with setState
try {
  final tournaments = await getTournaments();
  setState(() => this.tournaments = tournaments);
} catch (e) {
  setState(() => error = e.toString());
}
```

### 5. NAVIGATION
**ALWAYS use GoRouter with type-safe routing**
```dart
// ‚úÖ MODERN - GoRouter with code generation
@TypedGoRoute<LoginRoute>(path: '/login')
class LoginRoute extends GoRouteData {
  @override
  Widget build(BuildContext context, GoRouterState state) {
    return const LoginScreen();
  }
}

// Navigation
context.push(const TournamentRoute(id: tournamentId));

// ‚ùå OLD - Navigator.push
Navigator.push(
  context,
  MaterialPageRoute(builder: (context) => TournamentScreen(id: id)),
);
```

### 6. THEMING & DESIGN
**ALWAYS use Material Design 3 with dynamic theming**
```dart
// ‚úÖ MODERN - Material Design 3 + Dynamic colors
ThemeData(
  useMaterial3: true,
  colorScheme: ColorScheme.fromSeed(
    seedColor: const Color(0xFF3B82F6),
    brightness: Brightness.light,
  ),
  textTheme: GoogleFonts.interTextTheme(),
)

// Use semantic colors
Container(
  color: Theme.of(context).colorScheme.primaryContainer,
  child: Text(
    'Modern Text',
    style: Theme.of(context).textTheme.headlineMedium,
  ),
)

// ‚ùå OLD - Hardcoded colors
Container(
  color: Colors.blue[200],
  child: Text('Text', style: TextStyle(fontSize: 18)),
)
```

### 7. PERFORMANCE OPTIMIZATION
**ALWAYS use modern performance patterns**
```dart
// ‚úÖ MODERN - Optimized with const, keys, and efficient rebuilds
class TournamentCard extends ConsumerWidget {
  const TournamentCard({
    super.key,
    required this.tournament,
  });
  
  final Tournament tournament;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card.outlined(
      key: ValueKey(tournament.id),
      child: ListTile(
        leading: CircleAvatar(
          backgroundImage: CachedNetworkImageProvider(tournament.imageUrl),
        ),
        title: Text(tournament.name),
        subtitle: Text('${tournament.participants} participants'),
        onTap: () => TournamentRoute(id: tournament.id).push(context),
      ),
    );
  }
}

// ‚ùå OLD - Inefficient rebuilds, no const, no keys
Widget buildTournamentCard(Tournament tournament) {
  return Card(
    child: ListTile(
      title: Text(tournament.name),
      onTap: () => Navigator.push(context, ...),
    ),
  );
}
```

### 8. FORM HANDLING
**ALWAYS use modern form validation with hooks**
```dart
// ‚úÖ MODERN - Hook forms with validation
class LoginForm extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formKey = useMemoized(() => GlobalKey<FormState>());
    final email = useTextEditingController();
    final password = useTextEditingController();
    
    return Form(
      key: formKey,
      child: Column(
        children: [
          TextFormField(
            controller: email,
            decoration: const InputDecoration(labelText: 'Email'),
            validator: (value) => value?.isValidEmail == true 
              ? null 
              : 'Please enter a valid email',
            keyboardType: TextInputType.emailAddress,
            textInputAction: TextInputAction.next,
          ),
          const SizedBox(height: 16),
          TextFormField(
            controller: password,
            decoration: const InputDecoration(
              labelText: 'Password',
              suffixIcon: PasswordVisibilityToggle(),
            ),
            validator: (value) => value?.isValidPassword == true 
              ? null 
              : 'Password must be at least 8 characters',
            obscureText: true,
            textInputAction: TextInputAction.done,
          ),
          const SizedBox(height: 24),
          FilledButton(
            onPressed: () => _handleSubmit(formKey, email.text, password.text),
            child: const Text('Sign In'),
          ),
        ],
      ),
    );
  }
}

// ‚ùå OLD - Basic TextField with setState
TextField(
  onChanged: (value) => setState(() => email = value),
  decoration: InputDecoration(labelText: 'Email'),
)
```

### 9. API INTEGRATION
**ALWAYS use modern HTTP clients with proper typing**
```dart
// ‚úÖ MODERN - Dio with interceptors and proper error handling
@riverpod
Dio dio(DioRef ref) {
  final dio = Dio(BaseOptions(
    baseUrl: AppConfig.apiBaseUrl,
    connectTimeout: const Duration(seconds: 10),
    receiveTimeout: const Duration(seconds: 10),
  ));
  
  dio.interceptors.addAll([
    AuthInterceptor(ref),
    LogInterceptor(logPrint: logger.d),
    ErrorInterceptor(),
  ]);
  
  return dio;
}

@riverpod
class TournamentRepository extends _$TournamentRepository {
  @override
  FutureOr<void> build() {}
  
  Future<List<Tournament>> getTournaments({
    int page = 1,
    int limit = 20,
    String? search,
  }) async {
    final response = await ref.read(dioProvider).get(
      '/tournaments',
      queryParameters: {
        'page': page,
        'limit': limit,
        if (search != null) 'search': search,
      },
    );
    
    return (response.data['data'] as List)
        .map((json) => Tournament.fromJson(json))
        .toList();
  }
}

// ‚ùå OLD - Basic HTTP with manual error handling
Future<List<Tournament>> getTournaments() async {
  final response = await http.get(Uri.parse('$baseUrl/tournaments'));
  if (response.statusCode == 200) {
    // Manual JSON parsing...
  }
}
```

### 10. TESTING PATTERNS
**ALWAYS write testable code with dependency injection**
```dart
// ‚úÖ MODERN - Testable with Riverpod container override
void main() {
  group('LoginScreen Tests', () {
    testWidgets('should display error when login fails', (tester) async {
      final container = ProviderContainer(
        overrides: [
          authRepositoryProvider.overrideWithValue(
            MockAuthRepository()..setupLoginFailure(),
          ),
        ],
      );
      
      await tester.pumpWidget(
        UncontrolledProviderScope(
          container: container,
          child: MaterialApp(home: LoginScreen()),
        ),
      );
      
      await tester.enterText(find.byType(TextFormField).first, 'test@example.com');
      await tester.enterText(find.byType(TextFormField).last, 'password');
      await tester.tap(find.byType(FilledButton));
      await tester.pumpAndSettle();
      
      expect(find.text('Invalid credentials'), findsOneWidget);
    });
  });
}
```

## üéØ MODERN FLUTTER REQUIREMENTS

### CODE GENERATION
**ALWAYS use code generation for boilerplate reduction:**
```dart
// pubspec.yaml
dev_dependencies:
  build_runner: ^2.4.7
  riverpod_generator: ^2.3.9
  json_serializable: ^6.7.1
  go_router_builder: ^2.4.1

// Run: dart run build_runner build
```

### LINTING
**ALWAYS use strict linting rules:**
```yaml
# analysis_options.yaml
include: package:flutter_lints/flutter.yaml

analyzer:
  errors:
    invalid_annotation_target: ignore
  plugins:
    - custom_lint

linter:
  rules:
    - prefer_const_constructors
    - prefer_const_literals_to_create_immutables
    - avoid_print
    - prefer_single_quotes
    - require_trailing_commas
```

### EXTENSIONS
**ALWAYS create and use helpful extensions:**
```dart
// ‚úÖ MODERN - Custom extensions
extension StringX on String? {
  bool get isValidEmail => this?.contains('@') == true;
  bool get isValidPassword => (this?.length ?? 0) >= 8;
}

extension BuildContextX on BuildContext {
  ThemeData get theme => Theme.of(this);
  ColorScheme get colorScheme => theme.colorScheme;
  TextTheme get textTheme => theme.textTheme;
  
  void showSnackBar(String message) {
    ScaffoldMessenger.of(this).showSnackBar(
      SnackBar(content: Text(message)),
    );
  }
}

extension WidgetX on Widget {
  Widget padAll(double padding) => Padding(
    padding: EdgeInsets.all(padding),
    child: this,
  );
}
```

## üö´ ANTI-PATTERNS TO AVOID

### ‚ùå DON'T USE:
- `StatefulWidget` with `setState()` (use Riverpod + hooks)
- `Provider` package (use Riverpod)
- `Navigator.push()` (use GoRouter)
- Hardcoded colors/sizes (use theme)
- `FutureBuilder`/`StreamBuilder` (use Riverpod AsyncValue)
- Manual JSON parsing (use json_serializable)
- `showDialog()` (use modern dialog patterns)
- `SingleChildScrollView` everywhere (use slivers)

### ‚ùå AVOID THESE PATTERNS:
```dart
// Don't write widgets like this anymore
class OldWidget extends StatefulWidget {
  @override
  _OldWidgetState createState() => _OldWidgetState();
}

class _OldWidgetState extends State<OldWidget> {
  bool loading = false;
  
  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.blue,
      child: Text('Old style'),
    );
  }
}
```

## ‚úÖ MODERN FLUTTER CHECKLIST

When writing any Flutter code, ensure:
- [ ] Using Riverpod 2.4+ for state management
- [ ] Using GoRouter for navigation
- [ ] Using Material Design 3 theming
- [ ] Using const constructors everywhere possible
- [ ] Using proper key management
- [ ] Using AsyncValue for async operations
- [ ] Using extensions for common operations
- [ ] Using hooks for local state
- [ ] Using proper error handling
- [ ] Using code generation where applicable
- [ ] Following clean architecture principles
- [ ] Writing testable code

## üéØ EXAMPLE IMPLEMENTATION

When I ask you to create a screen or feature, structure it like this:

```dart
// 1. Data Models with JSON serialization
@JsonSerializable()
class Tournament {
  final String id;
  final String name;
  final DateTime startDate;
  
  Tournament({required this.id, required this.name, required this.startDate});
  
  factory Tournament.fromJson(Map<String, dynamic> json) => 
    _$TournamentFromJson(json);
  Map<String, dynamic> toJson() => _$TournamentToJson(this);
}

// 2. Repository with Riverpod
@riverpod
class TournamentRepository extends _$TournamentRepository {
  @override
  FutureOr<void> build() {}
  
  Future<List<Tournament>> getTournaments() async {
    final response = await ref.read(dioProvider).get('/tournaments');
    return (response.data as List)
        .map((json) => Tournament.fromJson(json))
        .toList();
  }
}

// 3. Provider for state management
@riverpod
Future<List<Tournament>> tournaments(TournamentsRef ref) {
  return ref.read(tournamentRepositoryProvider.notifier).getTournaments();
}

// 4. Modern UI with proper theming
class TournamentListScreen extends ConsumerWidget {
  const TournamentListScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final tournamentsAsync = ref.watch(tournamentsProvider);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Tournaments'),
        backgroundColor: context.colorScheme.surface,
      ),
      body: tournamentsAsync.when(
        data: (tournaments) => ListView.builder(
          itemCount: tournaments.length,
          itemBuilder: (context, index) => TournamentCard(
            tournament: tournaments[index],
          ),
        ),
        loading: () => const TournamentListShimmer(),
        error: (error, stack) => ErrorView(
          message: error.toString(),
          onRetry: () => ref.invalidate(tournamentsProvider),
        ),
      ),
    );
  }
}
```

This is how Flutter should be written in 2024-2025. Always use these modern patterns!
